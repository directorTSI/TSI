<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Programming: Lesson 9 - Mastering NumPy</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome CSS link removed as icons are no longer needed -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            line-height: 1.7;
            -webkit-print-color-adjust: exact;
            color-adjust: exact;
            background-color: #F8FAFC; /* Light background */
            color: #1F2937; /* Dark text */
        }
        .container {
            max-width: 1080px;
            margin-left: auto;
            margin-right: auto;
            padding: 2.5rem 3rem;
            background-color: #FFFFFF;
            box-shadow: 0 8px 20px rgba(0,0,0,0.08);
            border-radius: 1rem;
            margin-top: 2rem;
            margin-bottom: 2rem;
        }
        /* Header */
        header {
            background-color: #FFFFFF; /* White header background */
            color: #1F2937; /* Dark text for header */
            padding: 0.8rem 1.5rem;
            box-shadow: 0 4px 10px rgba(0,0,0,0.08);
            display: flex;
            flex-direction: column; /* Stack logo/title and nav buttons */
            align-items: center; /* Center horizontally */
            position: sticky;
            top: 0;
            z-index: 1000;
            border-bottom: 3px solid #E5E7EB; /* Subtle light gray border at bottom of header */
        }
        header .header-left {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            flex-shrink: 0;
            margin-bottom: 0.5rem; /* Space below header-left block */
            width: 100%; /* Occupy full width for centering */
            justify-content: center; /* Center content within header-left */
        }
        header img {
            width: 48px;
            height: 48px;
            border-radius: 9999px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            flex-shrink: 0;
        }
        header .header-text-block {
            text-align: center; /* Center title text */
            line-height: 1.2;
            flex-grow: 1;
        }
        header .institute-name {
            font-size: 0.95rem;
            font-weight: 800;
            color: #0A2463; /* Dark blue for institute name */
            margin-bottom: 0.05rem;
            letter-spacing: 0.07em;
        }
        header .course-lesson-title {
            font-size: 0.8rem;
            color: #374151; /* Darker gray for course title */
            line-height: 1.2;
        }
        header .author-name {
            font-size: 0.75rem;
            color: #6B7280; /* Medium gray for author name */
            margin-top: 0.1rem;
            display: block;
        }

        /* Main Navigation Bar (Returned and functional) */
        .main-nav-bar {
            background-color: #FDFDFD;
            padding: 0.8rem 2rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            border-bottom: 1px solid #E5E7EB;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 1rem; /* Spacing between main nav items */
            width: 100%; /* Occupy full width within header */
            border-top: 1px solid #E5E7EB; /* Separator from header-left */
            padding-top: 1rem; /* Add padding above buttons */
        }
        .main-nav-item {
            background-color: transparent;
            color: #3E92CC; /* Bright Teal for default text */
            padding: 0.4rem 1rem;
            border: 1px solid #93C5FD; /* Lighter blue border for pill shape */
            border-radius: 9999px; /* Pill shape */
            font-size: 0.85rem;
            font-weight: 600;
            text-decoration: none;
            transition: all 0.2s ease-in-out;
            white-space: nowrap;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer; /* Indicate it's clickable */
        }
        .main-nav-item:hover, .main-nav-item.active { /* 'active' for scroll spy */
            background-color: #DBEAFE; /* Lighter blue background on hover/active */
            color: #0A2463; /* Dark blue text on hover/active */
            transform: translateY(-2px);
            box-shadow: 0 1px 5px rgba(0,0,0,0.1);
        }
        /* Icon styling removed as icons are now removed */


        /* Side TOC is removed */
        .toc-container {
            display: none !important;
        }

        /* Headings - No collapsible functionality here */
        h2, h3, h4 {
            cursor: default; /* No pointer cursor for non-collapsible */
            /* Removed data-level attributes and toggle-icon spans from HTML */
        }
        h2:hover, h3:hover, h4:hover {
            color: inherit; /* No color change on hover */
        }

        /* Title Styles */
        h2 {
            font-size: 2.5rem; /* Larger for main titles */
            font-weight: 800; /* Extra bold */
            color: #0A2463; /* Deep blue */
            margin-top: 3.5rem; /* More space above */
            margin-bottom: 1.5rem; /* More space below */
            padding-bottom: 0.75rem; /* More padding below for border */
            border-bottom: 3px solid #3E92CC; /* Thicker, brighter blue border */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.05); /* Subtle shadow for depth */
        }
        h3 {
            font-size: 2rem; /* Larger for sub-titles */
            font-weight: 700; /* Bold */
            color: #3E92CC; /* Bright Teal */
            margin-top: 2.5rem; /* More space above */
            margin-bottom: 1rem; /* More space below */
        }
        h4 {
            font-size: 1.5rem; /* Larger for sub-sub-titles */
            font-weight: 600; /* Semi-bold */
            color: #0A2463; /* Dark blue */
            margin-top: 2rem; /* More space above */
            margin-bottom: 0.75rem;
        }


        p {
            margin-bottom: 1rem;
            color: #374151;
        }
        ul, ol {
            list-style-type: disc;
            margin-left: 1.5rem;
            margin-bottom: 1rem;
            color: #374151;
        }
        ol {
            list-style-type: decimal;
        }
        strong {
            font-weight: bold;
            color: #1F2937;
        }

        /* Jupyter-style code blocks (static for examples) */
        .jupyter-cell {
            background-color: #F8FAFC;
            border-radius: 0.5rem;
            border: 1px solid #E2E8F0;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
            margin: 1.5rem 0;
            overflow: hidden;
        }
        .jupyter-input-wrapper { /* For In[] block content */
            background-color: #FFFFFF;
            padding: 1rem;
            border-bottom: 1px solid #E2E8F0;
            position: relative;
            padding-left: 3.5rem;
            font-family: 'Fira Code', 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            color: #0A2463;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .jupyter-input-wrapper::before {
            content: 'In [ ] :';
            position: absolute;
            left: 0.75rem;
            top: 1rem;
            font-size: 0.8rem;
            color: #6B7280;
            font-family: sans-serif;
            font-weight: bold;
        }
        .jupyter-output { /* For Out[] block content */
            background-color: #F0F9FF;
            padding: 1rem;
            font-family: 'Fira Code', 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            color: #3E92CC;
            font-weight: normal; /* Normal weight for output */
            overflow-x: auto;
            white-space: pre-wrap;
            word-break: break-all;
            position: relative;
            padding-left: 3.5rem;
            text-indent: -2.5rem; /* Negative indent for alignment */
        }
        .jupyter-output::before {
            content: 'Out[ ] :';
            position: absolute;
            left: 0.75rem;
            top: 1rem;
            font-size: 0.8rem;
            color: #6B7280;
            font-family: sans-serif;
            font-weight: bold;
        }
        .jupyter-input .keyword {
            color: #0A2463;
            font-weight: bold;
        }
        .jupyter-input .comment { color: #6B7280; font-style: italic; }

        /* No interactive code elements, copy buttons */
        .copy-button, .code-actions, #reveal-solutions-button {
            display: none !important;
        }
        
        footer {
            background-color: #1F2937;
            color: white;
            padding: 1.5rem 0;
            text-align: center;
            font-size: 0.9rem;
            margin-top: 2rem;
        }

        /* Quiz Specific Styling - purely static questions */
        .quiz-section .question-card {
            background-color: #FFFFFF;
            padding: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
            margin-bottom: 1.5rem;
            border-left: 4px solid #93C5FD;
        }
        .quiz-section .question-text {
            font-size: 1.1rem;
            font-weight: 600;
            color: #0A2463;
            margin-bottom: 1rem;
        }
        /* Hide entire code-setup-block from quiz section */
        .quiz-section .code-setup-block {
            display: none !important;
        }

        /* Remove all solution-related divs and their children */
        .code-solution-box,
        #reveal-solutions-button
        {
            display: none !important;
        }


        @media print {
            body {
                background-color: #FFFFFF !important;
                color: #000000 !important;
                margin: 0;
                padding: 0;
                font-size: 9pt;
            }
            .container {
                box-shadow: none !important;
                margin: 0;
                padding: 1cm;
                border-radius: 0;
                width: 100%;
            }
            header, footer {
                background-color: #FFFFFF !important;
                color: #000000 !important;
                box-shadow: none !important;
                padding: 0.5cm 0;
                text-align: center;
                border-bottom: none !important;
            }
            header .header-left {
                display: flex !important;
                flex-direction: row !important;
                align-items: center !important;
                justify-content: center !important;
                width: 100% !important;
                gap: 0.5cm !important;
            }
            header img {
                width: 50px !important;
                height: 50px !important;
                margin-bottom: 0 !important;
            }
            header .institute-name, header .course-lesson-title, header .author-name {
                color: #000000 !important;
                font-size: 10pt !important;
                margin: 0 !important;
            }
            header .institute-name { font-weight: bold !important; letter-spacing: normal !important; }
            header .course-lesson-title { font-size: 8pt !important; }
            header .author-name { font-size: 8pt !important; }
            .main-nav-bar { display: none !important; } /* Hide main nav in print */

            h2, h3, h4 {
                color: #000000 !important;
                border-bottom-color: #AAAAAA !important;
                cursor: auto !important;
                page-break-after: avoid;
                margin-top: 1.5cm;
            }
            h2:hover, h3:hover, h4:hover { color: #000000 !important; }
            p, ul, ol, pre {
                page-break-inside: avoid;
                margin-bottom: 0.8rem;
            }
            .jupyter-cell {
                border: 1px solid #DDDDDD !important;
                box-shadow: none !important;
                background-color: #F9F9F9 !important;
                margin: 1rem 0;
                page-break-inside: avoid;
            }
            .jupyter-input-wrapper {
                background-color: #FDFDFD !important;
                color: #000000 !important;
                border-bottom-color: #E0E0E0 !important;
            }
            .jupyter-input-textarea { /* Should not exist */
                display: none !important;
            }
            .jupyter-input .keyword {
                color: #333333 !important;
                font-weight: bold;
            }
            .jupyter-input::before, .jupyter-output::before {
                color: #777777 !important;
            }
            .jupyter-output {
                background-color: #F0F0F0 !important;
                color: #444444 !important;
                font-weight: normal;
                display: block !important;
            }
            strong {
                color: #000000 !important;
            }
            .copy-button, .code-actions { display: none !important; }
            .collapsible-content > div {
                 min-height: auto !important;
                 overflow: visible !important;
            }
            .toggle-icon { display: none !important; }
            .toc-container { display: none !important; }
            .main-layout { flex-direction: column !important; }
            .property-box { background-color: #F9F9F9 !important; border-color: #E0E0E0 !important; }
            .property-title { color: #000000 !important; }
            .property-example { background-color: #F0F0F0 !important; }

            /* Quiz section specific print styles */
            .quiz-section .question-card {
                border-color: #E0E0E0 !important;
            }
            .quiz-section .expected-code-label, .quiz-section .expected-output-label, .quiz-section .explanation-label {
                color: #000000 !important;
            }
            .quiz-section .expected-code-snippet {
                background-color: #F9F9F9 !important;
                border-color: #E0E0E0 !important;
                color: #000000 !important;
            }
            .quiz-section .expected-output-content {
                background-color: #F0F0F0 !important;
                border-color: #E0E0E0 !important;
                color: #000000 !important;
            }
            .quiz-section .explanation-text {
                color: #333333 !important;
            }
            .quiz-section .code-solution-box .code-input-display {
                border-bottom: none !important;
                margin-bottom: 0 !important;
                padding-bottom: 0.5rem !important;
            }
            .quiz-section .code-solution-box .code-output-display {
                display: none !important; /* Explicitly hide outputs in print */
            }
            .quiz-section .solution-container {
                display: none !important; /* Hide solution containers for print */
            }
        }
    </style>
</head>
<body>

    <header>
        <div class="header-left">
            <img src="logotsi.jpeg" alt="Tech Savvy Institute Logo" onerror="this.onerror=null;this.src='https://placehold.co/48x48/0A2463/FFFFFF?text=TSI'; this.alt='Logo Placeholder';">
            <div class="header-text-block">
                <p class="institute-name">TECH SAVVY INSTITUTE</p>
                <p class="course-lesson-title">Python Programming Fundamentals - Lesson 9: Mastering NumPy</p>
                <span class="author-name">by Maurice Otieno</span>
            </div>
        </div>
    </header>

    <nav class="main-nav-bar">
        <a href="#introduction-to-numpy" class="main-nav-item">Introduction</a>
        <a href="#numpy-array-essentials" class="main-nav-item">Essentials</a>
        <a href="#installation-verification" class="main-nav-item">Installation</a>
        <a href="#efficiency-numpy-arrays" class="main-nav-item">Efficiency</a>
        <a href="#properties-numpy-arrays" class="main-nav-item">Properties</a>
        <a href="#methods-creating-numpy-arrays" class="main-nav-item">Creation</a>
        <a href="#precision-indexing" class="main-nav-item">Indexing</a>
        <a href="#broadcasting-demystified" class="main-nav-item">Broadcasting</a>
        <a href="#array-manipulation" class="main-nav-item">Manipulation</a>
        <a href="#practical-applications" class="main-nav-item">Applications</a>
        <a href="#coding-challenges" class="main-nav-item">Challenges</a>
    </nav>

    <div class="container">
        <!-- Main Content Area - takes full width as TOC is removed -->
        <div class="main-content w-full">

            <section id="introduction-to-numpy">
                <h2>1. Introduction to NumPy</h2>
                <div>
                    <p>NumPy (Numerical Python) is a fundamental, open-source Python library essential for numerical computations. It provides support for large, multi-dimensional arrays and matrices, along with a collection of high-level mathematical functions to operate on these arrays. NumPy is the cornerstone for many other scientific Python libraries, including Pandas, SciPy, and Matplotlib.</p>
                    <p>This lesson aims to equip participants with a profound understanding and practical mastery of NumPy's core functionalities beyond basic array creation. Upon completion, participants will be able to:</p>
                    <ul>
                        <li>Comprehend and utilize advanced indexing techniques, including integer, boolean, and fancy indexing, for precise data selection.</li>
                        <li>Master array slicing for efficient data extraction and modification, recognizing the crucial distinction between views and copies to prevent unintended data alterations.</li>
                        <li>Grasp the concept of broadcasting and leverage it for highly optimized vectorized operations across arrays of different shapes, significantly improving computational efficiency.</li>
                        <li>Perform various array manipulations, such as reshaping, concatenating, and splitting, to prepare and transform data for complex analytical pipelines.</li>
                        <li>Appreciate the profound performance and memory benefits that NumPy operations offer compared to standard Python structures, enabling more efficient handling and processing of large-scale datasets in real-world applications.</li>
                    </ul>
                </div>
            </section>

            <section id="numpy-array-essentials">
                <h2>2. NumPy Array Essentials: A Quick Review</h2>
                <div>
                    <p>At the core of NumPy's functionality is the `ndarray` object, a homogeneous, multi-dimensional array designed for numerical data. All elements within a NumPy `ndarray` must be of the same data type. This homogeneity allows NumPy to store data in contiguous blocks of memory, a critical factor for enabling highly optimized, C-level operations without the overhead of Python's dynamic typing and object management. Furthermore, once an `ndarray` is created, its total size cannot change, and its shape must be "rectangular."</p>
                    <p>Every NumPy array possesses several key attributes that describe its structure and content:</p>
                    <ul>
                        <li><strong>`ndim`</strong>: Number of axes, or dimensions, of the array.</li>
                        <li><strong>`shape`</strong>: A tuple of integers, specifying the size of the array along each dimension.</li>
                        <li><strong>`size`</strong>: Total number of elements in the array.</li>
                        <li><strong>`dtype`</strong>: An object describing the data type of the elements within the array.</li>
                        <li><strong>`itemsize`</strong>: Size in bytes of each element in the array.</li>
                    </ul>
                    <p><strong>NumPy `ndarray` Key Attributes Summary:</strong></p>
                    <div class="jupyter-cell">
                        <div class="jupyter-input-wrapper">
                            <pre class="jupyter-code-content">
import numpy as np
arr = np.array([[1, 2], [3, 4]])

print(f"ndim: {arr.ndim}")
print(f"shape: {arr.shape}")
print(f"size: {arr.size}")
print(f"dtype: {arr.dtype}")
print(f"itemsize: {arr.itemsize}")
                            </pre>
                        </div>
                        <div class="jupyter-output">
                            ndim: 2
                            shape: (2, 2)
                            size: 4
                            dtype: int64
                            itemsize: 8
                        </div>
                    </div>
                </div>
            </section>

            <section id="installation-verification">
                <h2>3. Installation & Verification</h2>
                <div>
                    <p>Before you can harness the power of NumPy, you need to install it and import it into your Python environment. For demonstration purposes, cloud-based environments like Google Colab are often preferred due to their speed and pre-installed libraries, similar to local Jupyter Notebook installations.</p>

                    <h3>3.1. Installing NumPy</h3>
                    <div>
                        <p>NumPy is easily installed using Python's package managers:</p>
                        <ul>
                            <li><strong>Using `pip` (standard Python installer):</strong> This command is typically run in your terminal or command prompt.
                                <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">pip install numpy</pre></div></pre>
                            </li>
                            <li><strong>Using `conda` (for Anaconda/Miniconda users):</strong> If you are using the Anaconda distribution, `conda` is the recommended package manager.
                                <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">conda install numpy</pre></div></pre>
                            </li>
                        </ul>
                        <p><strong>Note:</strong> If you encounter installation issues (e.g., in Jupyter Notebook directly), Google Colab (colab.research.google.com) comes with NumPy pre-installed, offering an immediate alternative for practice.</p>
                    </div>

                    <h3>3.2. Importing and Verifying NumPy</h3>
                    <div>
                        <p>Once installed, you need to import the library into your Python script or notebook session. The common convention is to import it with the alias `np` for convenience.</p>
                        <div class="jupyter-cell">
                            <div class="jupyter-input-wrapper">
                                <pre class="jupyter-code-content">
import numpy as np

# Check the installed version
print(np.__version__)
                                </pre>
                            </div>
                            <div class="jupyter-output">
                                1.26.4 <span class="comment"># (Example version, may vary based on installation)</span>
                            </div>
                        </div>
                        <p>If executing `print(np.__version__)` results in an error, it typically indicates that NumPy was not installed or imported correctly.</p>
                    </div>
                </div>
            </section>

            <section id="efficiency-numpy-arrays">
                <h2>4. Efficiency of NumPy Arrays</h2>
                <div>
                    <p>A primary reason for using NumPy is its superior efficiency and speed for numerical computations compared to standard Python lists. This is especially evident when dealing with large datasets.</p>
                    <p>NumPy's performance advantage stems from its ability to process data in optimized, fixed-type arrays, leveraging underlying C implementations. This "vectorization" of operations allows for significant speed-ups over Python's dynamic lists, which are less efficient for mathematical tasks.</p>
                    <p><strong>Comparison Example: Squaring 1 Million Numbers</strong></p>
                    <div class="jupyter-cell">
                        <div class="jupyter-input-wrapper">
                            <pre class="jupyter-code-content">
import time
import numpy as np

# Using Python Lists
my_list = list(range(1000000))
start_time_list = time.time()
list_squares = [x**2 for x in my_list]
end_time_list = time.time()
print(f"Time for Python list: {end_time_list - start_time_list:.4f} seconds")

# Using NumPy Arrays
my_array = np.arange(1000000)
start_time_array = time.time()
array_squares = my_array**2 # Element-wise operation
end_time_array = time.time()
print(f"Time for NumPy array: {end_time_array - start_time_array:.4f} seconds")
                            </pre>
                        </div>
                        <div class="jupyter-output">
                            Time for Python list: 0.1234 seconds <span class="comment"># (Example output)</span><br>
                            Time for NumPy array: 0.0012 seconds <span class="comment"># (Example output, significantly faster)</span>
                        </div>
                    </div>
                </div>
            </section>

            <section id="properties-numpy-arrays">
                <h2>5. Properties of NumPy Arrays</h2>
                <div>
                    <p>NumPy arrays (`ndarray`) have distinct properties that define their structure and contents:</p>

                    <h3>5.1. Shape (`.shape`)</h3>
                    <div>
                        <p>The `shape` property returns a tuple indicating the dimensions or organization of the array (e.g., number of rows, columns, etc.). It describes how the data is arranged.</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
arr1d = np.array([1, 2, 3, 4])
arr2d = np.array([[1, 2, 3], [4, 5, 6]])

print("Shape of 1D array:", arr1d.shape)
print("Shape of 2D array:", arr2d.shape)</pre></div><div class="jupyter-output">Shape of 1D array: (4,)<br>Shape of 2D array: (2, 3)</div></pre>
                        <p>The "dimension" of an array refers to the number of axes or dimensions it has (e.g., a 1D array has one dimension, a 2D array has two dimensions). The shape specifies the size along each dimension.</p>
                    </div>

                    <h3>5.2. Size (`.size`)</h3>
                    <div>
                        <p>The `size` property returns the total number of elements (values) in the array, regardless of its shape or dimensions.</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
arr = np.array([[1, 2, 3], [4, 5, 6]])
print("Total elements:", arr.size)</pre></div><div class="jupyter-output">Total elements: 6</div></pre>
                    </div>

                    <h3>5.3. Data Type (`.dtype`)</h3>
                    <div>
                        <p>The `dtype` property indicates the data type of the elements stored within the array (e.g., `int32`, `float64`, `bool`). All elements in a NumPy array must be of the same data type, which contributes to its efficiency.</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
arr_int = np.array([1, 2, 3])
arr_float = np.array([1.0, 2.5])
arr_bool = np.array([True, False])

print("Data type of integer array:", arr_int.dtype)
print("Data type of float array:", arr_float.dtype)
print("Data type of boolean array:", arr_bool.dtype)</pre></div><div class="jupyter-output">Data type of integer array: int64<br>Data type of float array: float64<br>Data type of boolean array: bool</div></pre>
                    </div>
                </div>
            </section>

            <section id="methods-creating-numpy-arrays">
                <h2>6. Methods for Creating NumPy Arrays</h2>
                <div>
                    <p>NumPy provides numerous convenient methods to create arrays quickly, initializing them with specific values or patterns.</p>

                    <h3>6.1. From Python Lists (`np.array()`)</h3>
                    <div>
                        <p>The most common way to create a NumPy array is by passing a Python list (or a list of lists for multi-dimensional arrays) to the `np.array()` function.</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
# Creating a one-dimensional array
arr_1d = np.array([10, 20, 30])
print("1D Array:", arr_1d)
print("Shape:", arr_1d.shape)

# Creating a two-dimensional array (matrix)
arr_2d = np.array([[1, 2, 3], [4, 5, 6]])
print("2D Array:\n", arr_2d)
print("Shape:", arr_2d.shape)</pre></div><div class="jupyter-output">1D Array: [10 20 30]<br>Shape: (3,)<br>2D Array:<br>[[1 2 3]<br> [4 5 6]]<br>Shape: (2, 3)</div></pre>
                    </div>

                    <h3>6.2. Arrays of Zeros (`np.zeros()`)</h3>
                    <div>
                        <p>Creates a new array of a specified shape, filled with zeros. The data type defaults to float unless specified.</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
zeros_array = np.zeros((2, 3)) # 2 rows, 3 columns, filled with 0s
print(zeros_array)</pre></div><div class="jupyter-output">[[0. 0. 0.]<br> [0. 0. 0.]]</div></pre>
                    </div>

                    <h3>6.3. Arrays of Ones (`np.ones()`)</h3>
                    <div>
                        <p>Creates a new array of a specified shape, filled with ones. Also defaults to float data type.</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
ones_array = np.ones((3, 2)) # 3 rows, 2 columns, filled with 1s
print(ones_array)</pre></div><div class="jupyter-output">[[1. 1.]<br> [1. 1.]<br> [1. 1.]]</div></pre>
                    </div>

                    <h3>6.4. Arrays with Full Value (`np.full()`)</h3>
                    <div>
                        <p>Creates an array of a specified shape, filled with a single custom value.</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
full_array = np.full((2, 2), 7) # 2x2 array filled with 7
print(full_array)</pre></div><div class="jupyter-output">[[7 7]<br> [7 7]]</div></pre>
                    </div>

                    <h3>6.5. Identity Matrix (`np.eye()`)</h3>
                    <div>
                        <p>Creates a square 2D array (matrix) where the main diagonal elements are ones and all other elements are zeros. Important in linear algebra.</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
identity_matrix = np.eye(4) # Creates a 4x4 identity matrix
print(identity_matrix)</pre></div><div class="jupyter-output">[[1. 0. 0. 0.]<br> [0. 1. 0. 0.]<br> [0. 0. 1. 0.]<br> [0. 0. 0. 1.]]</div></pre>
                    </div>

                    <h3>6.6. Sequential Numbers (`np.arange()`)</h3>
                    <div>
                        <p>Similar to Python's built-in `range()` function, but it returns a NumPy array (`ndarray`) instead of a list or iterator. It's often used for creating evenly spaced values within a given interval.</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
# Array from 0 up to (but not including) 5
seq_array_1 = np.arange(5)
print("Seq 0-4:", seq_array_1)

# Array from 1 up to (but not including) 6
seq_array_2 = np.arange(1, 6)
print("Seq 1-5:", seq_array_2)

# Array from 0 up to (but not including) 10, with a step of 2
seq_array_3 = np.arange(0, 10, 2)
print("Seq by 2:", seq_array_3)</pre></div><div class="jupyter-output">Seq 0-4: [0 1 2 3 4]<br>Seq 1-5: [1 2 3 4 5]<br>Seq by 2: [0 2 4 6 8]</div></pre>
                    </div>

                    <h3>6.7. Evenly Spaced Numbers (`np.linspace()`)</h3>
                    <div>
                        <p>Returns numbers evenly spaced over a specified interval. It takes the start, stop, and number of points to generate (inclusive of both start and stop by default).</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
linspace_array = np.linspace(0, 1, 5) # 5 evenly spaced points between 0 and 1
print(linspace_array)</pre></div><div class="jupyter-output">[0.   0.25 0.5  0.75 1.  ]</div></pre>
                    </div>

                    <h3>6.8. Random Numbers (from `np.random` module)</h3>
                    <div>
                        <p>NumPy's `random` module provides various functions for generating arrays of random numbers, crucial for simulations, statistical analysis, and machine learning.</p>
                        <ul>
                            <li>`np.random.rand(d0, d1, ...)`: Creates an array of random floating-point numbers between 0 (inclusive) and 1 (exclusive), drawn from a uniform distribution.</li>
                            <li>`np.random.randint(low, high, size)`: Generates random integers from `low` (inclusive) to `high` (exclusive).</li>
                            <li>`np.random.randn(d0, d1, ...)`: Returns samples from the "standard normal" (Gaussian) distribution (mean 0, variance 1).</li>
                        </ul>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
# Random floats between 0 and 1
random_floats = np.random.rand(2, 3) # 2x3 array
print("Random Uniform (0-1):\n", random_floats)

# Random integers
random_ints = np.random.randint(1, 10, size=(2, 2)) # 2x2 integers from 1 to 9
print("Random Integers (1-9):\n", random_ints)

# Random numbers from standard normal distribution
random_normal = np.random.randn(2, 2) # 2x2 array
print("Random Normal:\n", random_normal)</pre></div><div class="jupyter-output">Random Uniform (0-1):<br>[[0.456 0.123 0.789]<br> [0.987 0.654 0.321]] <span class="comment"># (Output will vary each time)</span><br>Random Integers (1-9):<br>[[4 7]<br> [1 9]] <span class="comment"># (Output will vary)</span><br>Random Normal:<br>[[ 0.53  -0.98 ]<br> [-0.12   1.45 ]] <span class="comment"># (Output will vary)</span></div></pre>
                    </div>
                </div>
            </section>
            
            <section id="precision-indexing">
                <h2>7. Precision Indexing: Navigating NumPy Arrays</h2>
                <div>
                    <p>NumPy offers a highly versatile and powerful set of indexing capabilities that extend far beyond standard Python list indexing, enabling precise data selection and manipulation within multi-dimensional arrays.</p>

                    <h3>7.1. Basic Integer Indexing</h3>
                    <div>
                        <p>For one-dimensional arrays, individual elements are accessed using integer indices, starting from `0`. Negative indices can be used to access elements from the end of the array, with `-1` referring to the last element.</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
arr_1d = np.array([10, 20, 30, 40])

print(f"First element (positive index): {arr_1d[0]}")
print(f"Last element (negative index): {arr_1d[-1]}")</pre></div><div class="jupyter-output">First element (positive index): 10<br>Last element (negative index): 40</div></pre>
                        <p>For multi-dimensional arrays, elements are accessed by specifying an index for each axis within a single set of square brackets, separated by commas (e.g., `array[row_index, column_index]`).</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
arr_2d = np.array([[1, 2, 3, 4],
                   [5, 6, 7, 8],
                   [9, 10, 11, 12]])

# Access element at row 1 (second row), column 3 (fourth column)
print(f"Element at (1, 3): {arr_2d[1, 3]}")</pre></div><div class="jupyter-output">Element at (1, 3): 8</div></pre>
                    </div>

                    <h3>7.2. Boolean/Conditional Indexing</h3>
                    <div>
                        <p>Selects elements that satisfy specific conditions by using a boolean array of the same shape as the original array. Elements corresponding to `True` values are selected.</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

# Select elements less than 5
print(f"Elements < 5: {arr[arr < 5]}")

# Select even numbers
print(f"Even numbers: {arr[arr % 2 == 0]}")

# Combine conditions using logical operators (& for AND, | for OR)
print(f"Elements > 2 AND < 8: {arr[(arr > 2) & (arr < 8)]}")</pre></div><div class="jupyter-output">Elements < 5: [1 2 3 4]<br>Even numbers: [ 2  4  6  8 10]<br>Elements > 2 AND < 8: [3 4 5 6 7]</div></pre>
                        <p>The `np.where()` function can also be used for conditional selection, applying a condition across an entire array without explicit looping.</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
ages = np.array([15, 20, 25, 30, 35, 40])

# If age > 18, assign 'Adult', else 'Minor'
result = np.where(ages > 18, "Adult", "Minor")
print(f"Age groups: {result}")</pre></div><div class="jupyter-output">Age groups: ['Minor' 'Adult' 'Adult' 'Adult' 'Adult' 'Adult']</div></pre>
                    </div>

                    <h3>7.3. Indexing with Arrays of Indices (Fancy Indexing)</h3>
                    <div>
                        <p>Selects multiple non-contiguous elements, rows, or columns by passing a list or an array of integer indices. <strong>Fancy indexing always returns a copy</strong> of the selected data, not a view.</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
arr = np.array([10, 20, 30, 40, 50])

# Select elements at specific indices (0, 2, 4)
selected_elements = arr[[0, 2, 4]]
print(f"Selected elements: {selected_elements}")

# Select specific rows from a 2D array
matrix = np.array([[1, 2, 3],
                   [4, 5, 6],
                   [7, 8, 9]])
selected_rows = matrix[[0, 2]] # Select row 0 and row 2
print(f"Selected rows:\n{selected_rows}")</pre></div><div class="jupyter-output">Selected elements: [10 30 50]<br>Selected rows:<br>[[1 2 3]<br> [7 8 9]]</div></pre>
                        <p><strong>Important: Fancy indexing returns a COPY.</strong> Modifying the result will NOT affect the original array.</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
original_arr = np.array([10, 20, 30, 40, 50])
fancy_indexed_copy = original_arr[[1, 3]] # This is a copy

print(f"Original before change: {original_arr}")
print(f"Modified copy: {fancy_indexed_copy}")

fancy_indexed_copy[0] = 99 # Modify the copy
print(f"Original after change: {original_arr}") # Original array is UNCHANGED!
print(f"Copy after change: {fancy_indexed_copy}")</pre></div><div class="jupyter-output">Original before change: [10 20 30 40 50]<br>Modified copy: [20 40]<br>Original after change: [10 20 30 40 50]<br>Copy after change: [99 40]</div></pre>
                    </div>

                    <h3>7.4. `np.nonzero()` for Conditional Indices</h3>
                    <div>
                        <p>Identifies the indices of non-zero elements or elements that meet a specific condition. It returns a tuple of arrays, one for each dimension, containing the indices.</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
arr = np.array([[1, 0, 3],
                [0, 5, 0],
                [7, 0, 9]])

# Get indices of non-zero elements
row_indices, col_indices = np.nonzero(arr)
print(f"Non-zero element row indices: {row_indices}")
print(f"Non-zero element column indices: {col_indices}")

# Get indices of elements less than 5
rows_lt5, cols_lt5 = np.nonzero(arr < 5)
print(f"Indices of elements < 5 (rows): {rows_lt5}")
print(f"Indices of elements < 5 (cols): {cols_lt5}")

# Access elements using these indices
print(f"Elements < 5: {arr[rows_lt5, cols_lt5]}")</pre></div><div class="jupyter-output">Non-zero element row indices: [0 0 1 2 2]<br>Non-zero element column indices: [0 2 1 0 2]<br>Indices of elements < 5 (rows): [0 0 0]<br>Indices of elements < 5 (cols): [0 1 2]<br>Elements < 5: [1 0 3]</div></pre>
                    </div>
                </div>
            </section>

            <section id="broadcasting-demystified">
                <h2>8. Broadcasting Demystified: Operations Across Shapes</h2>
                <div>
                    <p>Broadcasting is a powerful and highly optimized feature in NumPy that allows arithmetic operations to be performed on arrays with different shapes. It conceptually "stretches" or "replicates" the smaller array across the larger one to make their shapes compatible, without actually copying the data in memory.</p>

                    <h3>8.1. General Broadcasting Rules</h3>
                    <div>
                        <p>NumPy compares array shapes element-wise, starting from the trailing (rightmost) dimension and moving left. Two dimensions are compatible if:</p>
                        <ol>
                            <li>They are equal.</li>
                            <li>One of them is 1.</li>
                        </ol>
                        <p>If these conditions are not met, NumPy will raise a `ValueError`. Missing dimensions are assumed to have a size of one (left-padded with ones).</p>
                        <p>The resulting array will have the same number of dimensions as the input array with the greatest number of dimensions, and the size of each dimension in the result will be the largest size of the corresponding dimension among the input arrays.</p>
                    </div>

                    <h3>8.2. Broadcasting Examples</h3>
                    <div>
                        <h4>Scalar and Array:</h4>
                        <p>The simplest form involves combining an array with a scalar value. The scalar is conceptually stretched to match the array's shape.</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
a = np.array([1.0, 2.0, 3.0])
b = 2.0 # Scalar

result = a * b
print(f"Result of scalar multiplication: {result}")</pre></div><div class="jupyter-output">Result of scalar multiplication: [2. 4. 6.]</div></pre>

                        <h4>1D Array to 2D Array:</h4>
                        <p>A 1D array can be added to a 2D array, with the 1D array conceptually stretched to match each row of the 2D array.</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
a_2d = np.array([[0.0, 0.0, 0.0],
                 [10.0, 10.0, 10.0],
                 [20.0, 20.0, 20.0]])
b_1d = np.array([1.0, 2.0, 3.0])

result = a_2d + b_1d
print(f"Result of 1D to 2D addition:\n{result}")</pre></div><div class="jupyter-output">Result of 1D to 2D addition:<br>[[ 1.  2.  3.]<br> [11. 12. 13.]<br> [21. 22. 23.]]</div></pre>

                        <h4>Examples of Shapes that Do Not Broadcast:</h4>
                        <p>Broadcasting fails when the compatibility rules are not met (trailing dimensions are neither equal nor is one of them 1).</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
arr1 = np.array([1, 2, 3]) # Shape (3,)
arr2 = np.array([1, 2, 3, 4]) # Shape (4,)

try:
    result = arr1 + arr2
    print(f"Result: {result}")
except ValueError as e:
    print(f"Error: {e}")
print("Shapes (3,) and (4,) are incompatible for direct broadcasting.")</pre></div><div class="jupyter-output">Error: operands could not be broadcast together with shapes (3,) (4,)<br>Shapes (3,) and (4,) are incompatible for direct broadcasting.</div></pre>
                    </div>
                </div>
            </section>

            <section id="array-manipulation">
                <h2>9. Array Manipulation: Reshaping, Combining, and Dividing</h2>
                <div>
                    <p>NumPy provides a comprehensive suite of functions for manipulating array structures, indispensable for preparing data for analysis.</p>

                    <h3>9.1. Reshaping Arrays (`.reshape()`)</h3>
                    <div>
                        <p>Changes the shape of an array without altering its underlying data. The new shape must be compatible with the original number of elements. Use `-1` as a placeholder for one dimension to auto-calculate it.</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
arr = np.arange(1, 17) # 1D array from 1 to 16
print(f"Original 1D array:\n{arr}")

# Reshape to a 4x4 matrix
matrix = arr.reshape((4, 4))
print(f"\nReshaped 4x4 matrix:\n{matrix}")

# Reshape to 2 rows, let NumPy calculate columns
matrix_auto_cols = arr.reshape((2, -1))
print(f"\nReshaped to 2 rows (auto cols):\n{matrix_auto_cols}")</pre></div><div class="jupyter-output">Original 1D array:<br>[ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16]<br><br>Reshaped 4x4 matrix:<br>[[ 1  2  3  4]<br> [ 5  6  7  8]<br> [ 9 10 11 12]<br> [13 14 15 16]]<br><br>Reshaped to 2 rows (auto cols):<br>[[ 1  2  3  4  5  6  7  8]<br> [ 9 10 11 12 13 14 15 16]]</div></pre>
                    </div>

                    <h3>9.2. Combining Arrays</h3>
                    <div>
                        <h4>`np.concatenate()`:</h4>
                        <p>Joins a sequence of arrays along an existing axis. Arrays must have the same shape except for the concatenation axis.</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
a = np.array([[1, 2], [3, 4]]) # Shape (2, 2)
b = np.array([[5, 6]])         # Shape (1, 2)

# Concatenate along axis=0 (rows)
concat_rows = np.concatenate((a, b), axis=0)
print(f"Concatenated rows (axis=0):\n{concat_rows}")

# Concatenate along axis=1 (columns) - requires compatible shapes
c = np.array([[7], [8]]) # Shape (2, 1)
concat_cols = np.concatenate((a, c), axis=1)
print(f"\nConcatenated columns (axis=1):\n{concat_cols}")</pre></div><div class="jupyter-output">Concatenated rows (axis=0):<br>[[1 2]<br> [3 4]<br> [5 6]]<br><br>Concatenated columns (axis=1):<br>[[1 2 7]<br> [3 4 8]]</div></pre>

                        <h4>Convenience Functions (`np.vstack()`, `np.hstack()`):</h4>
                        <p>`np.vstack()` (vertical stack) stacks arrays row-wise (axis=0). `np.hstack()` (horizontal stack) stacks arrays column-wise (axis=1).</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

# Vertical stack (adds rows)
v_stack = np.vstack((a, b))
print(f"Vertical Stack:\n{v_stack}")

# Horizontal stack (adds columns)
h_stack = np.hstack((a, b))
print(f"\nHorizontal Stack: {h_stack}")</pre></div><div class="jupyter-output">Vertical Stack:<br>[[1 2 3]<br> [4 5 6]]<br><br>Horizontal Stack: [1 2 3 4 5 6]</div></pre>
                    </div>

                    <h3>9.3. Dividing Arrays</h3>
                    <div>
                        <h4>`np.split()`:</h4>
                        <p>Divides an array into multiple sub-arrays (views). Can split into `N` equal parts or at specific indices. Raises `ValueError` if not equally divisible.</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
x = np.arange(9) # [0 1 2 3 4 5 6 7 8]

# Split into 3 equal arrays
split_equal = np.split(x, 3)
print(f"Split into 3 equal parts: {split_equal}")

# Split at specific indices
split_at_indices = np.split(x, [2, 5]) # Split before index 2, and before index 5
print(f"Split at indices [2, 5]: {split_at_indices}")</pre></div><div class="jupyter-output">Split into 3 equal parts: [array([0, 1, 2]), array([3, 4, 5]), array([6, 7, 8])]<br>Split at indices [2, 5]: [array([0, 1]), array([2, 3, 4]), array([5, 6, 7, 8])]</div></pre>

                        <h4>`np.array_split()`:</h4>
                        <p>Similar to `np.split()`, but more flexible; allows for unequal division without raising an error if not perfectly divisible.</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
x = np.arange(8) # [0 1 2 3 4 5 6 7]

# Split into 3 parts (unequal division allowed)
array_split_unequal = np.array_split(x, 3)
print(f"Array split into 3 parts: {array_split_equal}")</pre></div><div class="jupyter-output">Array split into 3 parts: [array([0, 1, 2]), array([3, 4, 5]), array([6, 7])]</div></pre>

                        <h4>Convenience Functions (`np.hsplit()`, `np.vsplit()`):</h4>
                        <p>`np.hsplit()` (horizontal split) divides column-wise. `np.vsplit()` (vertical split) divides row-wise.</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
matrix = np.arange(16).reshape((4, 4))
print(f"Original matrix:\n{matrix}")

# Horizontal split into 2 equal columns
h_split = np.hsplit(matrix, 2)
print(f"\nHorizontal Split (2 parts):\n{h_split}")

# Vertical split into 2 equal rows
v_split = np.vsplit(matrix, 2)
print(f"\nVertical Split (2 parts):\n{v_split}")</pre></div><div class="jupyter-output">Original matrix:<br>[[ 0  1  2  3]<br> [ 4  5  6  7]<br> [ 8  9 10 11]<br> [12 13 14 15]]<br><br>Horizontal Split (2 parts):<br>[array([[ 0,  1],<br>       [ 4,  5],<br>       [ 8,  9],
       [12, 13]]), array([[ 2,  3],<br>       [ 6,  7],<br>       [10, 11],<br>       [14, 15]])]<br><br>Vertical Split (2 parts):<br>[array([[ 0,  1,  2,  3],<br>       [ 4,  5,  6,  7]]), array([[ 8,  9, 10, 11],<br>       [12, 13, 14, 15]])]</div></pre>
                    </div>
                </div>
            </section>

            <section id="practical-applications">
                <h2>10. Practical Applications & Best Practices</h2>
                <div>
                    <p>The true power of NumPy lies in combining its features to solve real-world data processing challenges. This synthesis moves beyond theoretical knowledge to applied skill.</p>

                    <h3>10.1. Practical Applications</h3>
                    <div>
                        <h4>Data Normalization:</h4>
                        <p>Subtracting the mean and dividing by the standard deviation (a common step in machine learning) is simplified by broadcasting.</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
data = np.array([[10, 20, 30],
                 [12, 22, 33],
                 [8, 18, 27]])

# Calculate mean and std deviation for each column (axis=0)
mean = data.mean(axis=0)
std = data.std(axis=0)

# Normalize data using broadcasting
normalized_data = (data - mean) / std
print(f"Original Data:\n{data}")
print(f"\nMean per column: {mean}")
print(f"Std Dev per column: {std}")
print(f"\nNormalized Data (using broadcasting):\n{normalized_data}")</pre></div><div class="jupyter-output">Original Data:<br>[[10 20 30]<br> [12 22 33]<br> [ 8 18 27]]<br><br>Mean per column: [10.         20.         30.        ]<br>Std Dev per column: [1.63299316 1.63299316 2.44948974]<br><br>Normalized Data (using broadcasting):<br>[[ 0.         0.         0.        ]<br> [ 1.22474487 1.22474487 1.22474487]<br> [-1.22474487 -1.22474487 -1.22474487]]</div></pre>

                        <h4>Filtering and Aggregation:</h4>
                        <p>Combine boolean indexing with aggregation functions for complex data queries.</p>
                        <pre class="jupyter-cell"><div class="jupyter-input-wrapper"><pre class="jupyter-code-content">import numpy as np
sales_data = np.array([100, 150, 80, 200, 120, 250])

# Find sales greater than 120
high_sales = sales_data[sales_data > 120]
print(f"High sales (>120): {high_sales}")

# Calculate the mean of high sales
mean_high_sales = high_sales.mean()
print(f"Mean of high sales: {mean_high_sales}")</pre></div><div class="jupyter-output">High sales (>120): [150 200 250]<br>Mean of high sales: 200.0</div></pre>
                    </div>

                    <h3>10.2. Best Practices for NumPy</h3>
                    <div>
                        <ul>
                            <li><strong>Prefer Vectorized Operations:</strong> Always use NumPy's built-in functions and broadcasting over explicit Python `for` loops for performance.</li>
                            <li><strong>Understand Views vs. Copies:</strong> Be aware that slicing often returns a view. Use `.copy()` explicitly when an independent array is needed.</li>
                            <li><strong>Choose Appropriate `dtype`:** Select the smallest data type that can accurately represent your data to conserve memory.</li>
                            <li><strong>Pre-allocate Arrays:</strong> When the final array size is known, pre-allocate using `np.zeros()` or `np.empty()` to minimize memory reallocations.</li>
                            <li><strong>Readability:</strong> Ensure complex expressions remain readable. Use comments to clarify intent.</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section id="coding-challenges">
                <h2 data-level="2">11. Apply Your NumPy Knowledge</h2>
                <div>
                    <p class="text-lg text-primary-blue mb-4">These questions are designed to test your practical understanding of NumPy concepts. Write your Python code for each challenge in your preferred Python environment (like Google Colab or Jupyter Notebook).</p>
                    
                    <div class="quiz-section">
                        <div class="question-card">
                            <p class="question-text">1. <strong>Array Creation & Basic Properties:</strong> Create a 2D NumPy array (matrix) with 3 rows and 4 columns, filled with numbers from 1 to 12. Then, print its shape, size, and number of dimensions.</p>
                            <!-- code-setup-block removed -->
                        </div>

                        <div class="question-card">
                            <p class="question-text">2. <strong>Conditional Indexing & Summation:</strong> Create a 1D NumPy array `data = np.array([10, 25, 15, 40, 5, 30])`. Select all elements that are greater than 20. Then, calculate and print the sum of these selected elements.</p>
                            <!-- code-setup-block content removed -->
                        </div>

                        <div class="question-card">
                            <p class="question-text">3. <strong>Slicing & View vs. Copy:</strong> Create a 1D NumPy array `original_data = np.array([100, 200, 300, 400, 500])`. Create a slice `my_slice` containing elements from index 1 to 3 (inclusive). Modify the first element of `my_slice` to 999. Print both `original_data` and `my_slice` to show the effect of views. Then, create a *copy* of the same slice and modify its first element to 888, printing both the original and the copy to show no effect.</p>
                            <!-- code-setup-block content removed -->
                        </div>

                        <div class="question-card">
                            <p class="question-text">4. <strong>Broadcasting for Data Scaling:</strong> You have a 2D array representing daily sales for 3 products over 5 days: `sales = np.array([[10, 12, 15, 11, 13], [20, 22, 25, 21, 23], [5, 7, 8, 6, 9]])`. You also have a 1D array of `tax_rates = np.array([0.05, 0.10, 0.07])` (one rate per product). Use broadcasting to calculate the `tax_amount` for each sale. Print the `tax_amount` matrix. (Hint: You might need `np.newaxis` to align dimensions correctly for broadcasting).</p>
                            <!-- code-setup-block content removed -->
                        </div>

                        <div class="question-card">
                            <p class="question-text">5. <strong>Array Manipulation: Combine & Split:</strong> Create two 1D NumPy arrays: `arr1 = np.array([1, 2, 3])` and `arr2 = np.array([4, 5, 6])`. Concatenate them horizontally to form a new 1D array. Then, take this new concatenated array and split it into two equal parts. Print both the concatenated array and the two split parts.</p>
                            <!-- code-setup-block content removed -->
                        </div>
                        
                        <div class="question-card">
                            <p class="question-text">6. <strong>Matrix Transposition:</strong> Create a 3x2 NumPy array (matrix) and then print its transpose. Transposing a matrix swaps its rows and columns.</p>
                            <!-- code-setup-block content removed -->
                        </div>

                        <div class="question-card">
                            <p class="question-text">7. <strong>Filtering with `np.where()`:</strong> Create a 1D NumPy array `scores = np.array([65, 80, 70, 95, 50, 75])`. Use `np.where()` to create a new array where scores greater than 70 are replaced by 100, and scores 70 or less remain unchanged. Print the new array.</p>
                            <!-- code-setup-block content removed -->
                        </div>

                        <div class="question-card">
                            <p class="question-text">8. <strong>Creating an Array with Specific Data Type:</strong> Create a 1D NumPy array with values `[1, 2, 3]` but ensure its data type is explicitly `float64`. Print the array and its `dtype`.</p>
                            <!-- code-setup-block content removed -->
                        </div>

                        <div class="question-card">
                            <p class="question-text">9. <strong>Element-wise Power Calculation:</strong> Create a 1D NumPy array `bases = np.array([2, 3, 4])` and another `exponents = np.array([2, 3, 2])`. Calculate an array where each element in `bases` is raised to the power of the corresponding element in `exponents` (e.g., 2^2, 3^3, 4^2). Print the result.</p>
                            <!-- code-setup-block content removed -->
                        </div>

                        <div class="question-card">
                            <p class="question-text">10. <strong>Filtering 2D Array by Row Sum:</strong> Create a 2D array `matrix = np.array([[5, 10, 3], [8, 2, 7], [12, 4, 1]])`. Select and print only the rows where the sum of elements in that row is greater than 15.</p>
                            <!-- code-setup-block content removed -->
                        </div>

                        <div class="question-card">
                            <p class="question-text">11. <strong>Reshape to Column Vector:</strong> Create a 1D NumPy array `vec = np.array([1, 2, 3, 4, 5])`. Reshape it into a column vector (a 2D array with 5 rows and 1 column). Print the original array's shape and the new array's shape.</p>
                            <!-- code-setup-block content removed -->
                        </div>

                        <div class="question-card">
                            <p class="question-text">12. <strong>Concatenate Different Shaped Arrays:</strong> Create `arr_a = np.array([[1, 2], [3, 4]])` and `arr_b = np.array([[5, 6]])`. Concatenate `arr_a` and `arr_b` vertically along `axis=0`. Print the result. Then, create `arr_c = np.array([[7], [8]])` and concatenate it horizontally with `arr_a` along `axis=1`. Print this result.</p>
                            <!-- code-setup-block content removed -->
                        </div>

                        <div class="question-card">
                            <p class="question-text">13. <strong>Splitting a Matrix:</strong> Create a 4x4 identity matrix using `np.eye()`. Then, split this matrix into 4 equal parts both horizontally (into two 4x2 matrices) and vertically (into two 2x4 matrices). Print the resulting split arrays for both horizontal and vertical splits.</p>
                            <!-- code-setup-block content removed -->
                        </div>

                        <div class="question-card">
                            <p class="question-text">14. <strong>Scalar Array Arithmetic with `dtype`:</strong> Create a 1D NumPy array `prices = np.array([100, 200, 150])`. Add a `tax_rate` of 0.08 (float) to each price. Ensure the final `total_prices` array has an explicit `float32` data type. Print the `total_prices` array and its `dtype`.</p>
                            <!-- code-setup-block content removed -->
                        </div>

                        <div class="question-card">
                            <p class="question-text">15. <strong>Conditional Array Element Replacement:</strong> Create a 1D NumPy array `temp_readings = np.array([5, 12, 35, 8, 25, 40, 10])`. Replace all temperature readings below 10 with 5, and all readings above 30 with 30. Print the original array and the modified array.</p>
                            <!-- code-setup-block content removed -->
                        </div>

                        <div class="question-card">
                            <p class="question-text">16. <strong>Create an Array of Evenly Spaced Integers:</strong> Create a NumPy array that contains 7 evenly spaced integers between 0 and 20 (inclusive). Print the array and its `dtype`.</p>
                            <!-- code-setup-block content removed -->
                        </div>

                        <div class="question-card">
                            <p class="question-text">17. <strong>Calculate Mean of Specific Rows:</strong> Create a 2D array `data = np.array([[10, 12, 15], [20, 25, 30], [5, 8, 12]])`. Calculate and print the mean of the elements in the first row and the mean of the elements in the third row.</p>
                            <!-- code-setup-block content removed -->
                        </div>

                        <div class="question-card">
                            <p class="question-text">18. <strong>Find Max Value & Its Index:</strong> Create a 1D NumPy array `values = np.array([50, 10, 75, 20, 90, 30])`. Find and print the maximum value in the array, and also print the index of that maximum value.</p>
                            <!-- code-setup-block content removed -->
                        </div>

                        <div class="question-card">
                            <p class="question-text">19. <strong>Create a 3D Array of Zeros:</strong> Create a 3D NumPy array with dimensions 2x3x4 (2 'layers', 3 rows per layer, 4 columns per row). Fill it with zeros. Print the array and its shape.</p>
                            <!-- code-setup-block content removed -->
                        </div>

                        <div class="question-card">
                            <p class="question-text">20. <strong>Dot Product of Matrices:</strong> Create two 2x2 NumPy matrices: `matrix_A = np.array([[1, 2], [3, 4]])` and `matrix_B = np.array([[5, 6], [7, 8]])`. Calculate and print their dot product. (Hint: Use `np.dot()` or the `@` operator).</p>
                            <!-- code-setup-block content removed -->
                        </div>

                        <div class="question-card">
                            <p class="question-text">21. <strong>Standard Deviation by Column:</strong> Create a 3x3 NumPy array `data_matrix = np.array([[10, 12, 14], [15, 18, 21], [11, 13, 16]])`. Calculate and print the standard deviation of each column separately.</p>
                            <!-- code-setup-block content removed -->
                        </div>

                        <div class="question-card">
                            <p class="question-text">22. <strong>Generate Random Integers in Range:</strong> Generate a 1D NumPy array of 10 random whole numbers, where each number is between 50 (inclusive) and 100 (exclusive). Print the generated array.</p>
                            <!-- code-setup-block content removed -->
                        </div>

                        <div class="question-card">
                            <p class="question-text">23. <strong>Replace Elements Using `np.where()` (Advanced):</strong> Create a 1D array `data = np.array([1, 3, 5, 6, 10, 15, 20, 25, 30])`. Replace all numbers divisible by 3 with 0, and all numbers divisible by 5 with 100. Numbers divisible by both 3 and 5 should become 0 (prioritize 3's rule if overlapping). Print the modified array.</p>
                            <!-- code-setup-block content removed -->
                        </div>

                        <div class="question-card">
                            <p class="question-text">24. <strong>Nested Loops with NumPy Arrays:</strong> Create a 2D array `matrix = np.array([[10, 11, 12], [20, 21, 22]])`. Use nested Python `for` loops to iterate through each element of the matrix and print "Value at ([row_index], [col_index]): [value]".</p>
                            <!-- code-setup-block content removed -->
                        </div>

                        <div class="question-card">
                            <p class="question-text">25. <strong>Simulate Dice Rolls:</strong> Generate a 1D NumPy array named `dice_rolls` containing 10 random whole numbers between 1 and 6 (inclusive), simulating 10 dice rolls. Print the `dice_rolls` array. Then, print how many of these rolls resulted in a 6.</p>
                            <!-- code-setup-block content removed -->
                        </div>
                    </div>
                </div></div>
            </section>

        </div>
    </div>

    <footer>
        <p>&copy; 2024 Tech Savvy Institute. All rights reserved.</p>
        <p>Prepared by Maurice Otieno for Lesson 9: Introduction to NumPy.</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Function to handle smooth scrolling
            function smoothScroll(targetId) {
                const targetElement = document.querySelector(targetId);
                if (targetElement) {
                    const headerHeight = document.querySelector('header').offsetHeight;
                    const mainNavBarElement = document.querySelector('.main-nav-bar');
                    const navBarHeight = mainNavBarElement ? mainNavBarElement.offsetHeight : 0;
                    const totalOffset = headerHeight + navBarHeight + 5; // Add a small buffer

                    const elementPosition = targetElement.getBoundingClientRect().top + window.pageYOffset;
                    const offsetPosition = elementPosition - totalOffset;

                    window.scrollTo({
                        top: offsetPosition,
                        behavior: "smooth"
                    });
                }
            }

            // Get all main navigation items
            const navItems = document.querySelectorAll('.main-nav-bar .main-nav-item');
            
            // Get all sections with IDs to observe
            const sections = document.querySelectorAll('section[id]');

            // Attach click event listeners to navigation items
            navItems.forEach(item => {
                item.addEventListener('click', function(e) {
                    e.preventDefault(); // Prevent default anchor link behavior
                    const targetId = this.getAttribute('href'); // Get href attribute (e.g., "#introduction-to-numpy")
                    smoothScroll(targetId);
                });
            });

            // Scroll-spy functionality for active state
            const observerOptions = {
                root: null, // viewport
                rootMargin: `-80px 0px -50% 0px`, /* Adjust top margin for fixed header/nav and bottom for earlier activation */
                threshold: 0 /* Trigger as soon as target crosses rootMargin */
            };

            const observerCallback = (entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const currentSectionId = '#' + entry.target.id;
                        
                        // Remove 'active' class from all nav items
                        navItems.forEach(item => {
                            item.classList.remove('active');
                        });

                        // Add 'active' class to the corresponding nav item
                        const correspondingNavItem = document.querySelector(`.main-nav-item[href="${currentSectionId}"]`);
                        if (correspondingNavItem) {
                            correspondingNavItem.classList.add('active');
                        }
                    }
                });
            };

            const observer = new IntersectionObserver(observerCallback, observerOptions);

            // Observe each section
            sections.forEach(section => {
                observer.observe(section);
            });

            // Set initial active state on page load
            // Find the first section that is mostly in view or start with the first item
            const initialActiveSection = Array.from(sections).find(section => {
                const rect = section.getBoundingClientRect();
                return rect.top >= 0 && rect.top <= window.innerHeight / 2;
            }) || sections[0]; // Fallback to first section if none are sufficiently in view

            if (initialActiveSection) {
                const initialActiveNavItem = document.querySelector(`.main-nav-item[href="#${initialActiveSection.id}"]`);
                if (initialActiveNavItem) {
                    initialActiveNavItem.classList.add('active');
                }
            }
        });
    </script>
</body>
</html>
